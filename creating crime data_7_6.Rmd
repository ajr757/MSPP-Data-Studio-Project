---
title: "Data Project"
author: "Ally Rakus"
date: "6/22/2020"
output: github_document
---

Calling the packages 
```{r message=FALSE}
library(dplyr) # manipulate dataframes
library(readr) # read/write3 dataframes
library(ggplot2) # making plots
```

Import the crime data and reformat the date into the R date type (Y-M-D)
```{r}
library(readr)
library(fs)

bmore_crime_data_6_22 <- read_csv(path("bmore crime data_6_22.csv"),
 col_types = cols(
   CrimeDate = col_date(format = "%m/%d/%Y")
 )
)

bmore_crime_data_6_22

```

Filtering for incidents that occurred in years that match the census data (2014-2018)
```{r}
bmore_crime_data_2014_2018 <- filter(bmore_crime_data_6_22, between(CrimeDate, as.Date("2014-01-01"),as.Date("2018-12-31")))

bmore_crime_data_2014_2018
```

Removing duplicate rows 
```{r}
library(janitor)
bmore_crime_data_2014_2018 %>% get_dupes

```

Filtering for incidents considered to be property crime 
```{r}
bmore_property_crime_2014_2018 <- filter(bmore_crime_data_2014_2018, Description %in% c("BURGLARY", "LARCENY", "LARCENY FROM AUTO", "AUTO THEFT", "ARSON", "ROBBERY - STREET", "ROBBERY - CARJACKING", "ROBBERY - COMMERCIAL", "ROBBERY - RESIDENCE")
)

bmore_property_crime_2014_2018
```

Assigning a unique ID to each obs
```{r}
bmore_property_crime_2014_2018 %>% mutate(id = row_number())
```

Getting rid of incidents without coordinates/lat-long data and keeping variables of interest
```{r}
bmore_property_crime_2014_2018 %>% 
  filter(!Longitude == "NA") %>% 
  filter(!Latitude == "NA") %>% 
  select(Latitude, Longitude, District, Description, CrimeTime, CrimeDate)

```

Transforming the lat/lon data into spatial points 

**na.fail = false dropped datapoints with missing values
```{r}
library(sf)

bmore_property_crime_2014_2018_sf <- bmore_property_crime_2014_2018 %>% 
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326, na.fail = FALSE) %>% 
  st_transform(6487) # https://epsg.io/6487
```

Calling Census population data - helpful for creating crime rate for the census tracts
```{r}
library(tidycensus)

census_api_key("d432da892f8a6ce576e962e7170b27cf7ef13f8d", overwrite = TRUE, install = TRUE) 

bmore_tracts_pop <- get_acs(
  geography = "tract", 
  state = "MD",
  county = c("510"),
  variables = c("pop_num" = "B01001_001"),
  survey = "acs5",
  output = "wide",
  year = 2018,
  geometry = TRUE
) %>% 
  st_transform(6487)
```

```{r}

# When joining multiple points to single polygon we'll end up with a row for
# every point with all the data from the poloygon repeated. So to aggregate all
# those points up by tract, we can group by tract and use summarise. Since the
# ACS columns are just repeated for all the rows with the same tract ID we can
# just take the max() to get that same original value. Meanwhile for getting the
# cout of crimes, since each crime is represented by a row (point) in the crime
# data, we can just count up the rows with n(). Now we have a dataset with a row for each tract, the population, and the number of crimes. 

bmore_crime_tract <- bmore_tracts_pop %>% 
  st_join(bmore_property_crime_2014_2018_sf, join = st_intersects) %>% 
  # If you need a row for each year*tract combination, you can add year to the
  # group_by. But I think for what you're doing it makes sense to aggregate over
  # all the years since all the ACS data is done that way as 2014-2018 estimates
  # group_by(GEOID, year) %>%
  group_by(GEOID) %>% 
  summarise(
    pop_numE = max(pop_numE),
    pop_numM = max(pop_numM),
    n_crimes = n()
  ) %>% 
  ungroup()
  
 bmore_crime_tract 
```
Making a crime map - crime count 
```{r}
library(leaflet)
library(htmlwidgets)

#color palette for crime quantity
crime_quant_pal <- colorBin(
  palette = viridisLite::viridis(5), 
  domain = bmore_crime_tract$n_crimes, 
  n = 4
)

#creating the map
crime_map_1 <- bmore_crime_tract %>% 
  st_transform(4326) %>% 
  leaflet() %>% 
  addProviderTiles(providers$CartoDB.Positron) %>%
  
#plotting the black population layer 
  addPolygons(
    fillColor = ~crime_quant_pal(n_crimes),
    fillOpacity = 0.7,
    color = "white",
    weight = 0.5,
    group = "Crime Count"
  ) %>% 
  
  addLayersControl(
    overlayGroups = c("Crime Count"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>% 
  showGroup(c("Crime Count")) %>% 

#creating the legend for black population
  addLegend(
    position = "topleft", 
    pal = crime_quant_pal, 
    values = ~n_crimes, 
    title = "Crime Count<br>by Census Tract (2014-2018)",
    labFormat = labelFormat(suffix = "%")
  )

crime_map_1
```

Creating the crime rate per census tract variable 
```{r}
bmore_crime_rate_tract <- bmore_crime_tract %>% 
  mutate(
    crime_rate = n_crimes / na_if(pop_numE,0),
    crime_rate_moe = moe_prop(n_crimes, na_if(pop_numE,0), n_crimes, pop_numM)
  )

bmore_crime_rate_tract
```

Creating crime map 2 - crime rate per census tract 
```{r}
library(leaflet)
library(htmlwidgets)

#color palette for crime quantity
crime_rate_pal <- colorBin(
  palette = viridisLite::viridis(5), 
  domain = bmore_crime_rate_tract$crime_rate, 
  n = 4
)

#creating the map
crime_map_2 <- bmore_crime_rate_tract %>% 
  st_transform(4326) %>% 
  leaflet() %>% 
  addProviderTiles(providers$CartoDB.Positron) %>%
  
#plotting the black population layer 
  addPolygons(
    fillColor = ~crime_rate_pal(crime_rate),
    fillOpacity = 0.7,
    color = "white",
    weight = 0.5,
    group = "Crime Rate"
  ) %>% 
  
  addLayersControl(
    overlayGroups = c("Crime Rate"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>% 
  showGroup(c("Crime Rate")) %>% 

#creating the legend for black population
  addLegend(
    position = "topleft", 
    pal = crime_rate_pal, 
    values = ~crime_rate, 
    title = "Crime Rate<br>by Census Tract (2014-2018)",
    labFormat = labelFormat(suffix = "%")
  )

crime_map_2
```

ggplot() +
  geom_sf(data = bmore_property_crime_2014_2018_sf) +
  geom_sf(data = bmore_census_data_MERGED_FINAL)

**Need to do: 

REGRESSION
2. prep data to be merged with census data
3. merge with census data
4. run basic regressions 






